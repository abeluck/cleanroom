Data persistence is a somewhat tricky topic in a Live system context,
especially one explicitely designed to avoid leaving any trace of
its use.

Some real-life usecases however require to setup some kind of
data persistence, which should then be carefully introduced
and supported.

[[!toc levels=3]]

Usecases
========

What can be made persistent?
----------------------------

Here are the usecases that are of interest for our users and we want
to support.

### Application-specific configurations

This might be relevant for the following applications:

- gpg/ssh/vpn/OTR keys/configurations
- certificates
- IM and MUA configurations (since these can take a several
  steps to setup which is annoying to redo for every amnesia
  session)
- Tor's data/cache for faster bootstrap with slow connections and
  better protections through more stable entry guards (/var/lib/tor)
- I2P data/cache/log directory (/var/lib/i2p)
- NoScript global behaviour (whitelist / blacklist) and exceptions

Perhaps it would be possible to make a tool/list so that the user can
choose exactly what files/directories that should be persistent, and
and when to update them? With such a general solution the above
things would not have to be implemented individually and could
be present as default suggestions in the tool, and advanced users
with uncommon requirements can do whatever they want so we won't hear
them nagging all the time.

Stuff we don't want to actively support making persistent:

- web browser addons (while we don't want to make it impossible to
  install addons, we think it's a really bad idea, and won't actively
  support it, since it partitions the Tails users anonymity set, thus
  having bad consequences both on people who do it *and* on others)

### User data store

A persistent non-home data store for whatever random files the user
wants to have persistent.

### Additional applications installation

If a user need some program
not present in amnesia per default it can be quite annoying to fetch
the apt information (which takes a lot of time over tor) and
download it (also slow), it could be nice to have a persistent
directory (or similar) where all .deb-files are installed at
boot time.

### Postponed

* [[todo/system_wide_persistence]]
* [[todo/full_home_persistence]]

Persistence storage location
----------------------------

* Encrypted partition and/or encrypted archive file on a removable
  storage device.

### Postponed

* Use persistence without a persistence media: an encrypted persistent
  archive could be [[remotely stored|todo/remote_persistent_storage]]
  on existing storage services.

Profiles
--------

Some users may want to separate different Tails profiles depending on
the intended activity ([[examples|forum/Persistence_Discussion]]).

Specifications
==============

Once a persistent volume is enabled, two operation modes should be
supported:

* read-write access: changes to persistent files are saved
* read-only access to **only** be able to *use* persistent files
  (e.g. a GnuPG keyring) without leaving any new trace.

Moreover:

* Tails should default to use a persistent store it can detect on
  removable media *in read-only mode*.
* Read-write access to a persistent data store must not be the
  default: it must require a voluntary user action such as choosing
  enabling a "with read-write persistent data" option in the boot
  menu.
* The persistent data must be stored using strong, well-known, Free
  Software, peer-reviewed encryption tools.
* Blacklist fixed storage devices from the search for persistent
  volumes. Rationale: preventing the risk of using a malicious persistent volume
  seems more important than supporting the rare "I want to store my
  persistent volume on a fixed hard-disk" use-case.
  - grml's patch against `live-initramfs` to optionally set all
    harddisk devices to read-only mode was applied upstream as
    `97846cf1b1a`; this option should probably be forcibly enabled
    when the users chooses to activate some kind of persistency from
    the boot menu.

Roadmap
=======

[[!tag todo/code]]

The first use cases that will be supported are:

* persistent application-specific configurations;
* persistent user data store.

Implementing one of these brings support for the other one more or
less for free.

This work can be split this way:

1. Backend:
   - improve Debian Live tools so they are able to implement our
     specifications. This shall be done hand in hand with upstream so
     that we don't end up maintaining a forked `live-boot` indefinitely
     * wait for upstream to comment on our generalized overlays proposal
     * decide between snapshots and generalized overlays
     * implement generalized overlays or missing features in snapshots
   - factor bits out of `live-boot` to make them support being run at
     a later time of the boot process: the UI (persistence toggling,
     etc.) will take place in the [[tails-greeter|todo/TailsGreeter]]
     [[todo/boot_menu]]

2. User interface:
   - make it easy to bootstrap / enable such persistence features;
     this must be integrated into the post-installation process: at
     some point the encrypted persistent container must be created.
   - make it easy to specify which bits are persistent
   - make it easy to use such persistence features (i.e. without adding
     arguments to the kernel command line by hand)

3. Documentation

Implementation
==============

Debian Live already supports several kinds of persistence, including
snapshots of selected files and persistence store automounting, both
at the `$HOME` and system-wide levels.

Encryption of the persistent volumes is supported using cryptsetup or
loop-aes.

Application-specific configurations
-----------------------------------

Neither home automounting nor `live-snapshot` currently fit the
application-specific configuration persistence use case. Both because
they are not finely grained enough and persist too much. Two possible
paths to a usable implementation are:

* Improve `live-snapshot`. This seems like an easy starting point
  because it has an include list feature (`/etc/live-snapshot.list`).
* Generalize overlays (*-rw) to handle arbitrary directories, not just
  / and /home.

Tails will move most boot-time communication with the user to a
graphical [[todo/boot_menu]], [[replacing the GDM
greeter|todo/TailsGreeter]]. This implies our work on persistence
support shall at the end of the day allow live-snapshot to run this
late in the boot process, instead of run from live-boot as is
currently done.

**Note**: the following is the set of options that Debian Live needs
to support both their current functionality and our usecase(s). Tails
will pre-configure some of these in `/etc/live/` and/or
`/proc/cmdline`, and only a tiny subset of options will be made
available to users by the Tails [[todo/boot_menu]]).

We want to use `persistent-media=removable` or
`persistent-media=removable-usb` (in `live-boot` 3.x).

What needs to be done:

- In the long run we may want to support plain dm-crypt mappings
  hidden in files: something similar to the `live-media-offset` would
  be perfect; the UI side of it will be tricky if we want to ask the
  offset to the user; this could happen either in the boot menu or by
  hooking a menu that would probably run from inside the initramfs,
  before `scripts/live` attempts to copy snapshots data. See
  [[todo/boot_menu]].

If we want to base our persistence on snapshots:

- Add support for file deletion (e.g. by replacing cpio with rsync).

- The `do_snap_copy` sub-procedure calculates free memory but does not
  seem to check there if is actually enough.

- Generalize compression support? Only live-snapshot's cpio kind
  supports compression. If we want to support compression for other
  modes of operation, the user interface would be
  persistent-compression=....

- Generalize live-snapshot.list? Only live-snapshot's cpio kind
  supports this currently, so we would otherwise be unable to use
  other types if we come up with reasons for doing so.

If we want to base our persistence on overlays:

- Implement something like this:
  ["Design for custom mounts system"](http://live.debian.net/devel/rfc/persistence/).

Read-only mode
--------------

There are two main ways to support using a persistent store in
read-only mode:

* copy the persistent content at boot time to a filesystem location (aufs)
* merge the persistent volume with a "diff" branch on ramdisk using
  aufs, and mount the resultant device, so that the mountpoint is seen
  as writable by applications but no actual change is made on disk.

User interface
--------------

### at boot time

Choosing between various persistence modes calls for a more complex
(implementation-wise) boot menu. See [[todo/boot_menu]] and
[[todo/TailsGreeter]] for details.

### during runtime

XXX
