Data persistence is a somewhat tricky topic in a Live system context,
especially one explicitely designed to avoid leaving any trace of
its use.

Some real-life usecases however require to setup some kind of
data persistence, which should then be carefully introduced
and supported.

[[!toc levels=4]]

Usecases
========

What can be made persistent?
----------------------------

Here are the usecases that are of interest for our users and we want
to support.

### Application-specific configurations

This might be relevant for the following applications:

- GnuPG, SSH and OTR key pairs
- GnuPG configuration
- SSH client configuration
- iceweasel certificate trust
- Pidgin configuration
- MUA configuration
- Tor's data/cache for faster bootstrap with slow connections and
  better protections through more stable entry guards
  (`/var/lib/tor/`); beware, this will break tordate
  [[contribute/design/Time_syncing]]
- I2P data/cache/log directory (`/var/lib/i2p/`)
- NoScript global behaviour (whitelist / blacklist) and exceptions

Perhaps it would be possible to make a tool/list so that the user can
choose exactly what files/directories that should be persistent, and
and when to update them? With such a general solution the above
things would not have to be implemented individually and could
be present as default suggestions in the tool, and advanced users
with uncommon requirements can do whatever they want so we won't hear
them nagging all the time.

Stuff we don't want to actively support making persistent:

- web browser addons (while we don't want to make it impossible to
  install addons, we think it's a really bad idea, and won't actively
  support it, since it partitions the Tails users anonymity set, thus
  having bad consequences both on people who do it *and* on others)

### User data store

A persistent non-home data store for whatever random files the user
wants to have persistent.

### Additional applications installation

If a user need some program not present in Tails per default it can be
quite annoying to fetch the APT information and download it (slow over
Tor), it could be nice to have a persistent directory (or similar)
where all .deb-files are installed at boot time.

Persistence storage location
----------------------------

* Encrypted partition and/or encrypted archive file on a removable
  storage device.

Specifications
==============

Once a persistent volume is enabled, two operation modes should be
supported:

* read-write access: changes to persistent files are saved
* read-only access to **only** be able to *use* persistent files
  (e.g. a GnuPG keyring) without leaving any new trace.

Moreover:

* Tails should default to use *in read-only mode* a persistent store
  it can detect on removable media.
* Read-write access to a persistent data store must not be the
  default: it must require a voluntary user action such as choosing
  enabling a "with read-write persistent data" option in the boot
  menu.
* The persistent data must be stored using strong, well-known, Free
  Software, peer-reviewed encryption tools.
* Fixed storage devices must be blacklisted by default from the search for persistent
  volumes. Rationale: preventing the risk of using a malicious persistent volume
  seems more important than supporting the rare "I want to store my
  persistent volume on a fixed hard-disk" use-case.
  - grml's patch against `live-initramfs` to optionally set all
    harddisk devices to read-only mode was applied upstream as
    `97846cf1b1a`; this option should probably be forcibly enabled
    when the users chooses to activate some kind of persistency from
    the boot menu.

Roadmap
=======

[[!tag todo/code]]

This roadmap is about the set of persistence features we are going to
implement initially; see also:

* the [[list of what has been done already|todo/persistence/done]];
* [[many ideas|todo/persistence/later]] for further improvements.

First, we will support **persistent application-specific
configurations** and **persistent user data store**; implementing one
of these brings support for the other one more or less for free.

This work can be split this way:

## 1. Backend

- **improve Debian Live tools** so they are able to implement our
  specifications. This shall be done hand in hand with upstream so
  that we don't end up maintaining a forked `live-boot` indefinitely:
  * update generalized overlays proposal with dircombine option and
    changes it requires
  * *implement* generalized overlays and dircombine option
  * *nag upstream* until they comment on our generalized overlays
    proposal
  * get aforementioned changes *merged upstream*
  * update Debian Live *documentation* to match aforementioned changes
- **factor bits out of live-boot** to make them support being run at
  a later time of the boot process; rationale: the UI (persistence
  toggling, etc.) will take place in the
  [[tails-greeter|todo/TailsGreeter]] [[todo/boot_menu]]
  * *implement* these changes
  * get these changes *merged upstream*
- **move to live-boot and live-config 3.x**: Tails currently ships the
  stable (2.x) branches, whereas all changes we need are being done in
  the 3.x branches

## 2. User interface

- walk the last steps towards a working [[USB
  installer|todo/usb_install_and_upgrade]]: see [[what is left to
  do|todo/usb_install_and_upgrade/todo]]
- make it easy to **bootstrap persistent storage**
- make it easy to **configure which bits are persistent**
- make it easy to **enable persistence at boot time**

## 3. Documentation

### For users

Users must be explained:

- **how to use** Tails persistence features
- the **shortcomings** that come with using persistence in the context
  of Tails

### For developers

- update **[[design documentation|contribute/design]]**
- document what and how to **test** when [[preparing a Tails
  release|contribute/release_process/test]]

Implementation
==============

Backend
-------

Debian Live already supports several kinds of persistence, including
snapshots of selected files and persistence store automounting, both
at the `$HOME` and system-wide levels.

Encryption of the persistent volumes is supported using cryptsetup or
loop-aes.

Neither home automounting nor `live-snapshot` currently fit the
application-specific configuration persistence use case. Both because
they are not finely grained enough and persist too much.

We have decided to:

* [generalize overlays](http://live.debian.net/devel/rfc/persistence/)
  (`*-rw`) to handle arbitrary directories, not just `/` and `/home`,
* add a "linkfiles" (inspired by [Joey Hess'
  dircombine](http://git.kitenet.net/?p=joey/home.git;a=blob;f=bin/dircombine))
  option to create symlinks from the root of a non-persistent
  directory (e.g. `$HOME`) to regular files stored in
  a persistent location (e.g. `.gitconfig`, `.vimrc`, etc.)

### Example

Example `live.persist` configuration file:

	# source     destination       options
	/apt         /var/cache/apt
	/dotfiles    /home/amnesia     linkfiles

This will result in:

* `$MEDIA/apt` is bind-mounted onto `/var/cache/apt`
* `/home/amnesia/` contains symlinks to every file in `$MEDIA/dotfiles`

### Nota bene

The following is the set of options that Debian Live needs
to support both their current functionality and our usecase(s). Tails
will pre-configure some of these in `/etc/live/` and/or
`/proc/cmdline`, and only a tiny subset of options will be made
available to users by the Tails [[todo/boot_menu]]).

### Left to do

* Implement something like this:
  ["Design for custom mounts
  system"](http://live.debian.net/devel/rfc/persistence/).
* In the long run we may want to support plain dm-crypt mappings
  hidden in files: something similar to the `live-media-offset` would
  be perfect; the UI side of it will be tricky if we want to ask the
  offset to the user; this could happen either in the boot menu or by
  hooking a menu that would probably run from inside the initramfs,
  before `scripts/live` attempts to copy snapshots data. See
  [[todo/boot_menu]].

### Read-only mode

Our read-only mode will be implemented by merging the persistent
volume with a "diff" branch on ramdisk using aufs, and mount the
resultant device, so that the mountpoint is seen as writable by
applications but no actual change is made on disk.

User interface
--------------

### bootstrap persistent storage

This must be integrated at post-installation time: when a newly
installed Tails USB stick is first booted, and no persistent storage
is enabled (a second stick with persistent storage might be ready to
be used already), the user shall be prompted if s/he wants to setup
a persistent storage container in the free space left on the USB stick
by our USB installer.

#### Left to do

* specify features: draft, request for comments, discussion, consensus
* wait for USB installer to be ready
* implementation
* documentation

### configure which bits are persistent

This should automatically be run right after the persistent storage
bootstrap step.

The user should also be enabled to change the configuration later;
let's make the scope of this more complex case smaller to start with:

* let's only support *adding* to the list of persistent items
* how would doing such changes play with already enabled persistence?
  let's only support the easiest to implement, which is probably
  "persistence settings changes are taken into account at next boot"

#### Left to do

* specify features: draft, request for comments, discussion, consensus
* implementation
* documentation

#### draft

* by default setup, setup a linkfiles-enabled persistent
  `${HOME}/dotfiles`, preconfigured to have its contents symlinked
  into `$HOME`.
* apart of this, let's consider non-directories persistence an
  advanced feature: to start with, and possibly forever, this could
  only be configured by manually editing live-persist file

### enable persistence at boot time

Choosing between various persistence modes is one of the reasons why
we've need a graphical [[todo/boot_menu]]: [[todo/TailsGreeter]].

#### Left to do

* specify features: draft, request for comments, discussion, consensus
* implementation
* documentation

#### draft

* add a second (options) screen to tails-greeter
* ask whether to enable persistence at all; if yes, read-only or
  read-write
* communicate with `live-persist`
* deal with LUKS passphrase
* for a given persistent container, it's all or nothing: all bits of
  persistence configured in its `live.persist` are to be setup
* run backend (Debian Live) functions to setup persistent data where
  it belong

backend / tails-greeter interface
---------------------------------

### Long story short

0. The user chooses to toggle persistence on in `tails-greeter`.
0. Still in `tails-greeter`, the user chooses if s/he wants read-only
   or read-write persistence.
0. `tails-greeter` asks `live-boot` the list of possibly valid
   persistent containers.
0. For each such volume, `tails-greeter` asks the user to enter the
   passphrase or to skip it, and tries to unlock. `tails-greeter`
   deals with error catching, retrying, etc. as appropriate.
0. `tails-greeter` asks `live-boot` to setup persistence (at least
   custom mounts and linkfiles), passing it the list of volumes that
   were successfully unlocked.

### Interfacing

A `live-persist` script shall be written, implementing each kind of
`tails-greeter` to `live-boot` communication as a sub-command, such
as:

	live-persist [OPTIONS] list [LABEL]...
	live-persist [OPTIONS] activate VOLUME...

`live-persist` will report success and failure as any other
well-behaved synchronously-called shell script, that is: with
appropriate exit codes and `STDERR`.

### Possibly valid persistent containers

In our case, that is quite simple: it means removable LUKS encrypted
filesystem, stored on GPT partitions labeled `Tails-persistence` (or
similar, must be decided upon taking into account technical
restrictions such as what GPT supports).

This means we need to:

* make sure we can pass this desired label to `live-boot`, probably on
  the kernel command-line along with other parameters
* add GPT labels support to `live-boot` persistence containers
  discovery code

In other (non-GPT) usecases, generally, it would be filesystems
labeled with `live-rw` or `home-rw`, but if they're on encrypted
device, then `live-boot` has to unlock the parent device them to see
the label; also, in non-Tails usecases, any encrypted filesystem may
contain a `*-rw` file, and must be unlocked to know too; so any
encrypted device may be a valid persistent container that is worth
passing to `tails-greeter`; . `live-persist` will support non-Tails
usecases on a best-effort basis, leaving room for improvement in case
other developers want to add support for their preferred usecases.

### Asking live-persist to setup persistence

To start with, we'll factor out only the custom mounts part from the
main `live-boot` script; it depends on factoring out other kinds of
persistence (e.g. all types of unionfs-style filesystems) first.
