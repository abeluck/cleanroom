[[!toc levels=4]]

# Rationale

Partial upgrades should provide only what has changed between two
releases (deltas) and have a way to apply those changes to the
previous version. We call the file that contains this an Incremental
Upgrade Kit (IUK).

At boot-time the security warning telling that a new Tails version is available
should provide an automated way of doing the upgrade.

# Roadmap

[[!tag todo/code]]

## 1. Design

* Think the current design a bit deeper, discuss with other Tails
  developers, reach an agreement.

## 2. Infrastructure

* make it easy to **generate an Incremental Upgrade Kit** for a point release
* update **mirrors infrastructure** to support hosting Incremental Upgrade Kits

## 3. User interface

* make it easy to **install an Incremental Upgrade Kit**
* update the **security warning program**
* make it easy to **download an Incremental Upgrade Kit**

## 4. Documentation

### For users

Users must be explained how to download and install an incremental
upgrade kit.

### For developers

* update **[[design documentation|contribute/design]]**
* update **[[release process|contribute/release_process]]**
* document what and how to **test** when [[preparing a Tails
  point-release|contribute/release_process/test]]

# Implementation

## Infrastructure

### generate an IUK

* think the IUK format through
  - [Mozilla ARchive format (MAR)](https://wiki.mozilla.org/Software_Update:MAR)

Program that takes two Tails ISO images, and:

* builds the "diff" SquashFS
* gets the new kernel(s), initrd(s), bootloader configuration
* brings all this together into some kind of structured archive

### mirrors infrastructure

Notes:

* Using something like [Mozilla's
  channels](https://wiki.mozilla.org/Software_Update:Channels)
  (*release*, *beta*, *nightly*) would e.g. allow us to push beta
  updates earlier to a brave subset of users. Subscribing to a channel
  other than *release* is something that would be worth
  [[persisting|doc/first_steps/persistence]]. We are not likely to implement
  a channels system in phase one, but the infrastructure we setup
  should leave room for such future extension.

### Updates files

We want the client to get an answer to questions such as "I run
version N of product P on architecture A, what stable release update
is available?". To allow us changing the way the answer is computed in
the future, the amount of work done on the client's side should be
kept to a minimum. So, let's insert a level of indirection, and
pre-compute server-side the answer to the queries we want to support.

The answers are distributed on our HTTP servers in the form of a set
of `updates.yml` files.

All the client has to do is:

* build the URI to its `updates.yml` file (could even be done at build
  time, actually, and hard-coded into the image)
* fetch the `updates.yml` file at this URI
* verify the cryptographic signature of this file
* extract from `updates.yml` information about available updates
* display this information

#### updates.yml URL

(Heavily inspired by Mozilla's [Checking For
Updates](https://wiki.mozilla.org/Software_Update:Checking_For_Updates).)

* `/update`
* URL schema version (so we can change it in the future) 
* product name (e.g. *Tails*, but some day we might have *TailsServer*,
  *TailsHandheld* or whatever)
* product version -- the currently running version to upgrade from,
  e.g. *0.11* or *0.11.1*
* buildtarget (e.g. *i386*)
* channel (e.g. *release* or *beta*)
* `update.yml`

e.g. `/update/1/Tails/0.11/i386/beta/updates.yml`

Such a file shall be shipped along with its OpenPGP detached signature
(`updates.yml.pgp`).

#### updates.yml format

(Heavily inspired by Mozilla's [updates.xml
Format](https://wiki.mozilla.org/Software_Update:updates.xml_Format).)

Sequence of update elements; each describing an update to an
individual product version, with the following attributes:

* type -- *major* or *minor* (in phase one, all IUK will be about
  point-releases, and the type will therefore always be *minor*, but
  let's make room in case we want to announce major releases this way
  too at some point)
* version -- the version of this update, that is the version of the
  running product after the update is completed (e.g. *0.11.1*)
* detailsURL -- a URL to a web page with more information about the
  specified update (e.g.
  <https://tails.boum.org/news/version_0.11.1/>)

Within an update element there must be at least one and no more than
two patch elements. The patch element describes a patch file that
lives on a remote server that must be downloaded and applied to the
product to update it to that version. The attributes for patch are as
follows:

* type -- *full* or *incremental* (IUK are about incremental upgrades,
  but let's make room to announce full ISO images this way too at some
  point)
* URL -- A URL to the remote patch file.
* size -- The size of the update, in bytes.

Remaining question: do we want to include IUK hashes in `updates.yml`,
or ship detached PGP signatures for IUK files? If hashes, we need
additional attributes for patch:

* hashFunction -- The name of the hash function to execute to verify
  the integrity of the patch.
* hashValue -- The server-generated hash generated for the file.
  If the client generated value does not match this, the integrity
  check fails after download.

## User interface

### install an IUK

Once a user has downloaded an IUK, they must have it installed.

Write an installer for IUKs. Some of the USB installer's code can
probably be factored out and reused.

This should happen at the same time as normal Tails operation,
but very carefully, because we need to remount the boot medium
read-write.

* Tell the user we're going to run the upgrade.
* Remount the boot-medium read-write.
* Extract the IUK archive.
* Move kernels and initrd's in place.
* Move bootloader configuration in place.
* Install bootloader on MBR (probably not needed).
* Remount the boot-medium read-only.
* Tell the user the upgrade process is finished.
* Reboot.
* Something must delete the IUK archive at some point.

Resources:

* [Mozilla's updates
  processing](https://wiki.mozilla.org/Software_Update:Processing_Updates):
  building up some mechanism (such as their pending / applying /
  succeeded / failed status) to avoid retrying the same buggy update
  in a loop seems worth being considered.

### security warning program

The program currently telling that a new Tails version is available
should run (or point at) the downloader program if the new version is
a point-release, and else point at full upgrade documentation.

* Detects if the new version is a point-release (checking if an IUK is
  available is probably the simplest, most robust and future-proof way
  to do so)
* Points at the downloader.

### download an IUK

Write a downloader for Incremental Upgrade Kits.

* Takes two versions as arguments, downloads the IUK.
* Start the installer.
* Allow the user to save the IUK where they want.
* Bonus points if there's an opt-in way to have the download happen in
  the clear, that is without going through the Tor network.
* Allow overriding the URL for dev / testing purpose.

# Code

* Integration work is being done in the `feature/incremental-upgrades`
  branch of the main Tails [[contribute/Git]] repository.

# Security

* All communication to HTTP servers that provide `updates.yml` and IUK
  files is likely to be made in cleartext (`http://`). No security is
  to be expected from transport-level security here.
* All files (IUK, update files) are signed by the Tails OpenPGP
  signing key, so integrity and authenticity are well-covered.
* How much do we care about replay attacks? (e.g. an exit node replays
  an obsolete `updates.yml` file and hides the existence of a security
  update)
* How much do we care about DoS attacks? (e.g. an exit node that
  blocks access to our HTTP servers)

# Research

## Stacking squashfs images

Tails filesystem is already using `aufs` to provide a read-write filesystem on
top of the read-only `squashfs` image.

This system could probably be extended to support mounting multiple `squashfs`
filesystems on top of each others. Upgrades would be `squashfs` images with only
the files that have been modified since the previous releases. This handles file
deletions.

Shipping upgrades could be as simple as shipping those extra `squashfs` images.

Debian live supports such stacking already: see in `live-boot(7)` the
part about `/live/filesystem.module`.

Stacking squashfs images like this would still lack a way of upgrading the
kernel and the syslinux. This should also be handled by the automated upgrade
process.

### Initial test

Here is a test. First the procedure to create the *delta* squashfs image, to be
done as `root`:

    mkdir /mnt/tails-0.7.1
    mkdir /mnt/tails-0.7.2
    mount -o loop tails-i386-0.7.1.iso /mnt/tails-0.7.1
    mount -o loop tails-i386-0.7.2.iso /mnt/tails-0.7.2
    mkdir /mnt/tails-0.7.1-root
    mkdir /mnt/tails-0.7.2-root
    mount -o loop /mnt/tails-0.7.1/live/filesystem.squashfs /mnt/tails-0.7.1-root
    mount -o loop /mnt/tails-0.7.2/live/filesystem.squashfs /mnt/tails-0.7.2-root

    mkdir /mnt/upgrade-0.7.1-to-0.7.2
    mount -t tmpfs tmpfs /mnt/upgrade-0.7.1-to-0.7.2

    mkdir /mnt/union
    mount -t aufs -o br=/mnt/upgrade-0.7.1-to-0.7.2=rw:/mnt/tails-0.7.1-root=ro none /mnt/union
    rsync -avP --delete-after /mnt/tails-0.7.2-root/ /mnt/union/

    mksquashfs /mnt/upgrade-0.7.1-to-0.7.2 upgrade-0.7.1-to-0.7.2.squashfs

Compressed size (using default gzip compression) is 82 MB.

Not bad, and the new kernel is included, which can probably be avoided.

Now, let's upgrade an USB stick:

    mkdir /media/disk/live
    cp   /mnt/tails-0.7.1/live/filesystem.squashfs \
         upgrade-0.7.1-to-0.7.2.squashfs \
         /mnt/tails/0.7.2/live/vmlinuz \
         /mnt/tails/0.7.2/live/initrd.img \
       /media/disk/live

Then fiddle with GRUB or EXTLINUX.

On boot, the new squashfs gets properly integrated. *Whiteouts* are not
working. It looks like the `live-boot` 2.x mount options miss the `wh` attribute.
But wait, booting with `break=top` and modifying `/scripts/live` to replace
`roopt=rr` by `roopt=rr+wh` is enough to do the trick! Therefore,
we've added the `wh` attribute to `live-boot` 3.x.

Initial test is pretty conclusive!

## Discarded options

See the [[page about discarded options|todo/incremental_upgrades/archive]].
